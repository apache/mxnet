I"ý‚<!--- Licensed to the Apache Software Foundation (ASF) under one -->
<!--- or more contributor license agreements.  See the NOTICE file -->
<!--- distributed with this work for additional information -->
<!--- regarding copyright ownership.  The ASF licenses this file -->
<!--- to you under the Apache License, Version 2.0 (the -->
<!--- "License"); you may not use this file except in compliance -->
<!--- with the License.  You may obtain a copy of the License at -->

<!---   http://www.apache.org/licenses/LICENSE-2.0 -->

<!--- Unless required by applicable law or agreed to in writing, -->
<!--- software distributed under the License is distributed on an -->
<!--- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -->
<!--- KIND, either express or implied.  See the License for the -->
<!--- specific language governing permissions and limitations -->
<!--- under the License. -->

<h1 id="c-api-inference-tutorial">C++ API inference tutorial</h1>

<h2 id="overview">Overview</h2>
<p>MXNet provides various useful tools and interfaces for deploying your model for inference. For example, you can use <a href="https://github.com/awslabs/mxnet-model-server">MXNet Model Server</a> to start a service and host your trained model easily.
Besides that, you can also use MXNetâ€™s different language APIs to integrate your model with your existing service. We provide <a href="/api/python/docs/api/">Python</a>, <a href="/api/java/docs/api/#package">Java</a>, <a href="/api/scala/docs/api">Scala</a>, and <a href="/api/cpp/docs/api/">C++</a> APIs.
We will focus on the MXNet C++ API. We have slightly modified the code in <a href="https://github.com/apache/incubator-mxnet/tree/master/cpp-package/example/inference">C++ Inference Example</a> for our use case.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To complete this tutorial, you need to:</p>
<ul>
  <li>Complete the training part of <a href="/api/python/docs/tutorials/getting-started/gluon_from_experiment_to_deployment.html">Gluon end to end tutorial</a>.</li>
  <li>Learn the basics about <a href="/api/cpp">MXNet C++ API</a>.</li>
</ul>

<h2 id="setup-the-mxnet-c-api">Setup the MXNet C++ API</h2>

<p>To use the C++ API in MXNet, you need to build MXNet from source with C++ package. Please follow the <a href="/get_started/ubuntu_setup.html">built from source guide</a>, and <a href="/api/cpp">C++ Package documentation</a>.
The summary of those two documents is that you need to build MXNet from source with <code class="highlighter-rouge">USE_CPP_PACKAGE</code> flag set to 1. For example: <code class="highlighter-rouge">make -j USE_CPP_PACKAGE=1</code>.</p>

<h2 id="load-the-model-and-run-inference">Load the model and run inference</h2>

<p>After you complete <a href="/api/python/docs/tutorials/getting-started/gluon_from_experiment_to_deployment.html">the previous tutorial</a>, you will get the following output files:</p>
<ol>
  <li>Model Architecture stored in <code class="highlighter-rouge">flower-recognition-symbol.json</code></li>
  <li>Model parameter values stored in <code class="highlighter-rouge">flower-recognition-0040.params</code> (<code class="highlighter-rouge">0040</code> is for 40 epochs we ran)</li>
  <li>Label names stored in <code class="highlighter-rouge">synset.txt</code></li>
  <li>Mean and standard deviation values stored in <code class="highlighter-rouge">mean_std_224</code> for image normalization.</li>
</ol>

<p>Now we need to write the C++ code to load them and run prediction on a test image.
The full code is available in the <a href="https://github.com/apache/incubator-mxnet/tree/master/cpp-package/example/inference">C++ Inference Example</a>, we will walk you through it and point out the necessary changes to make for our use case.</p>

<h3 id="write-a-predictor-using-the-mxnet-c-api">Write a predictor using the MXNet C++ API</h3>

<p>In general, the C++ inference code should follow the 4 steps below. We can do that using a Predictor class.</p>
<ol>
  <li>Load the pre-trained model</li>
  <li>Load the parameters of pre-trained model</li>
  <li>Load the image to be classified in to NDArray and apply image transformation we did in training</li>
  <li>Run the forward pass and predict the class of the input image</li>
</ol>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Predictor</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">Predictor</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">Predictor</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">model_json_file</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">model_params_file</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">input_shape</span><span class="p">,</span>
              <span class="kt">bool</span> <span class="n">gpu_context_type</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">synset_file</span> <span class="o">=</span> <span class="s">""</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">mean_image_file</span> <span class="o">=</span> <span class="s">""</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">PredictImage</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">image_file</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Predictor</span><span class="p">();</span>

 <span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">LoadModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">model_json_file</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">LoadParameters</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">model_parameters_file</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">LoadSynset</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">synset_file</span><span class="p">);</span>
    <span class="n">NDArray</span> <span class="n">LoadInputImage</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">image_file</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">LoadMeanImageData</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">LoadDefaultMeanImageData</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">NormalizeInput</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">mean_image_file</span><span class="p">);</span>
    <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">FileExists</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">stat</span> <span class="n">buffer</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">NDArray</span> <span class="n">mean_img</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">NDArray</span><span class="o">&gt;</span> <span class="n">args_map</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">NDArray</span><span class="o">&gt;</span> <span class="n">aux_map</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">output_labels</span><span class="p">;</span>
    <span class="n">Symbol</span> <span class="n">net</span><span class="p">;</span>
    <span class="n">Executor</span> <span class="o">*</span><span class="n">executor</span><span class="p">;</span>
    <span class="n">Shape</span> <span class="n">input_shape</span><span class="p">;</span>
    <span class="n">NDArray</span> <span class="n">mean_image_data</span><span class="p">;</span>
    <span class="n">NDArray</span> <span class="n">std_dev_image_data</span><span class="p">;</span>
    <span class="n">Context</span> <span class="n">global_ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">::</span><span class="n">cpu</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mean_image_file</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="load-the-model-synset-file-and-normalization-values">Load the model, synset file, and normalization values</h3>

<p>In the Predictor constructor, you need to provide paths to saved json and param files. After that, add the following methods <code class="highlighter-rouge">LoadModel</code> and <code class="highlighter-rouge">LoadParameters</code> to load the network and its parameters. This part is the same as <a href="https://github.com/apache/incubator-mxnet/blob/master/cpp-package/example/inference/imagenet_inference.cpp">the example</a>.</p>

<p>Next, we need to load synset file, and normalization values. We have made the following change since our synset file contains flower names and we used both mean and standard deviation for image normalization.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * The following function loads the synset file.
 * This information will be used later to report the label of input image.
 */</span>
<span class="kt">void</span> <span class="n">Predictor</span><span class="o">::</span><span class="n">LoadSynset</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">synset_file</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileExists</span><span class="p">(</span><span class="n">synset_file</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"Synset file "</span> <span class="o">&lt;&lt;</span> <span class="n">synset_file</span> <span class="o">&lt;&lt;</span> <span class="s">" does not exist"</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Synset file does not exist"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"Loading the synset file."</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">fi</span><span class="p">(</span><span class="n">synset_file</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fi</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error opening synset file "</span> <span class="o">&lt;&lt;</span> <span class="n">synset_file</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Error in opening the synset file."</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lemma</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">lemma</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">output_labels</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">fi</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*
 * The following function loads the mean and standard deviation values.
 * This data will be used for normalizing the image before running the forward
 * pass.
 * The output data has the same shape as that of the input image data.
 */</span>
<span class="kt">void</span> <span class="n">Predictor</span><span class="o">::</span><span class="n">LoadMeanImageData</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"Load the mean image data that will be used to normalize "</span>
     <span class="o">&lt;&lt;</span> <span class="s">"the image before running forward pass."</span><span class="p">;</span>
  <span class="n">mean_image_data</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">global_ctx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">mean_image_data</span><span class="p">.</span><span class="n">SyncCopyFromCPU</span><span class="p">(</span>
        <span class="n">NDArray</span><span class="o">::</span><span class="n">LoadToMap</span><span class="p">(</span><span class="n">mean_image_file</span><span class="p">)[</span><span class="s">"mean_img"</span><span class="p">].</span><span class="n">GetData</span><span class="p">(),</span>
        <span class="n">input_shape</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="n">NDArray</span><span class="o">::</span><span class="n">WaitAll</span><span class="p">();</span>
   <span class="n">std_dev_image_data</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">global_ctx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
   <span class="n">std_dev_image_data</span><span class="p">.</span><span class="n">SyncCopyFromCPU</span><span class="p">(</span>
       <span class="n">NDArray</span><span class="o">::</span><span class="n">LoadToMap</span><span class="p">(</span><span class="n">mean_image_file</span><span class="p">)[</span><span class="s">"std_img"</span><span class="p">].</span><span class="n">GetData</span><span class="p">(),</span>
       <span class="n">input_shape</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
    <span class="n">NDArray</span><span class="o">::</span><span class="n">WaitAll</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="load-input-image">Load input image</h3>

<p>Now letâ€™s add a method to load the input image we want to predict and converts it to NDArray for prediction.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NDArray</span> <span class="n">Predictor</span><span class="o">::</span><span class="n">LoadInputImage</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">image_file</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileExists</span><span class="p">(</span><span class="n">image_file</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"Image file "</span> <span class="o">&lt;&lt;</span> <span class="n">image_file</span> <span class="o">&lt;&lt;</span> <span class="s">" does not exist"</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Image file does not exist"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"Loading the image "</span> <span class="o">&lt;&lt;</span> <span class="n">image_file</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">;</span>
  <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">image_file</span><span class="p">);</span>
  <span class="cm">/*resize pictures to (224, 224) according to the pretrained model*/</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">cv</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">channels</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">array</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat</span><span class="p">.</span><span class="n">data</span><span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">height</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">c</span><span class="p">]));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">NDArray</span> <span class="n">image_data</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">global_ctx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">image_data</span><span class="p">.</span><span class="n">SyncCopyFromCPU</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">input_shape</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="n">NDArray</span><span class="o">::</span><span class="n">WaitAll</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">image_data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="predict-the-image">Predict the image</h3>

<p>Finally, letâ€™s run the inference. Itâ€™s basically using MXNet executor to do a forward pass. To run predictions on multiple images, you can load the images in a list of NDArrays and run prediction in batches. Note that the Predictor class may not be thread safe. Calling it in multi-threaded environments was not tested. To utilize multi-threaded prediction, you need to use the C predict API. Please follow the <a href="https://github.com/apache/incubator-mxnet/tree/master/example/image-classification/predict-cpp">C predict example</a>.</p>

<p>An additional step is to normalize the image NDArrays values to <code class="highlighter-rouge">(0, 1)</code> and apply mean and standard deviation we just loaded.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * The following function runs the forward pass on the model.
 * The executor is created in the constructor.
 *
 */</span>
<span class="kt">void</span> <span class="n">Predictor</span><span class="o">::</span><span class="n">PredictImage</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">image_file</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Load the input image</span>
  <span class="n">NDArray</span> <span class="n">image_data</span> <span class="o">=</span> <span class="n">LoadInputImage</span><span class="p">(</span><span class="n">image_file</span><span class="p">);</span>

  <span class="c1">// Normalize the image</span>
  <span class="n">image_data</span><span class="p">.</span><span class="n">Slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/=</span> <span class="mf">255.0</span><span class="p">;</span>
  <span class="n">image_data</span> <span class="o">-=</span> <span class="n">mean_image_data</span><span class="p">;</span>
  <span class="n">image_data</span> <span class="o">/=</span> <span class="n">std_dev_image_data</span><span class="p">;</span>

  <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"Running the forward pass on model to predict the image"</span><span class="p">;</span>
  <span class="cm">/*
   * The executor-&gt;arg_arrays represent the arguments to the model.
   *
   * Copying the image_data that contains the NDArray of input image
   * to the arg map of the executor. The input is stored with the key "data" in the map.
   *
   */</span>
  <span class="n">image_data</span><span class="p">.</span><span class="n">CopyTo</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">executor</span><span class="o">-&gt;</span><span class="n">arg_dict</span><span class="p">()[</span><span class="s">"data"</span><span class="p">]));</span>
  <span class="n">NDArray</span><span class="o">::</span><span class="n">WaitAll</span><span class="p">();</span>

  <span class="c1">// Run the forward pass.</span>
  <span class="n">executor</span><span class="o">-&gt;</span><span class="n">Forward</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

  <span class="c1">// The output is available in executor-&gt;outputs.</span>
  <span class="k">auto</span> <span class="n">array</span> <span class="o">=</span> <span class="n">executor</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Copy</span><span class="p">(</span><span class="n">global_ctx</span><span class="p">);</span>
  <span class="n">NDArray</span><span class="o">::</span><span class="n">WaitAll</span><span class="p">();</span>

  <span class="cm">/*
   * Find out the maximum accuracy and the index associated with that accuracy.
   * This is done by using the argmax operator on NDArray.
   */</span>
  <span class="k">auto</span> <span class="n">predicted</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">ArgmaxChannel</span><span class="p">();</span>
  <span class="n">NDArray</span><span class="o">::</span><span class="n">WaitAll</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">best_idx</span> <span class="o">=</span> <span class="n">predicted</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">best_accuracy</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">At</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">best_idx</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">output_labels</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"The model predicts the highest accuracy of "</span> <span class="o">&lt;&lt;</span> <span class="n">best_accuracy</span> <span class="o">&lt;&lt;</span> <span class="s">" at index "</span>
       <span class="o">&lt;&lt;</span> <span class="n">best_idx</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">"The model predicts the input image to be a ["</span> <span class="o">&lt;&lt;</span> <span class="n">output_labels</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span>
       <span class="o">&lt;&lt;</span> <span class="s">" ] with Accuracy = "</span> <span class="o">&lt;&lt;</span> <span class="n">best_accuracy</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="compile-and-run-the-inference-code">Compile and run the inference code</h3>

<p>You can find the <a href="https://github.com/apache/incubator-mxnet/tree/master/cpp-package/example/inference">full code for the inference example</a> in the <code class="highlighter-rouge">cpp-package</code> folder of the project
, and to compile it use this <a href="https://github.com/apache/incubator-mxnet/blob/master/cpp-package/example/inference/Makefile">Makefile</a>.</p>

<p>Make a copy of the example code, rename it to <code class="highlighter-rouge">flower_inference</code> and apply the changes we mentioned above. Now you will be able to compile and run inference. Run <code class="highlighter-rouge">make all</code>. Once this is complete, run inference with the following parameters. Remember to set your <code class="highlighter-rouge">LD_LIBRARY_PATH</code> to point to MXNet library if you have not done so.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make all
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span><span class="o">=</span>:path/to/incubator-mxnet/lib
./flower_inference <span class="nt">--symbol</span> flower-recognition-symbol.json <span class="nt">--params</span> flower-recognition-0040.params <span class="nt">--synset</span> synset.txt <span class="nt">--mean</span> mean_std_224.nd <span class="nt">--image</span> ./data/test/lotus/image_01832.jpg
</code></pre></div></div>

<p>Then it will predict your image:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>17:38:51] resnet.cpp:150: Loading the model from flower-recognition-symbol.json

<span class="o">[</span>17:38:51] resnet.cpp:163: Loading the model parameters from flower-recognition-0040.params

<span class="o">[</span>17:38:52] resnet.cpp:190: Loading the synset file.
<span class="o">[</span>17:38:52] resnet.cpp:211: Load the mean image data that will be used to normalize the image before running forward pass.
<span class="o">[</span>17:38:52] resnet.cpp:263: Loading the image ./data/test/lotus/image_01832.jpg

<span class="o">[</span>17:38:52] resnet.cpp:299: Running the forward pass on model to predict the image
<span class="o">[</span>17:38:52] resnet.cpp:331: The model predicts the input image to be a <span class="o">[</span>lotus <span class="o">]</span> with Accuracy <span class="o">=</span> 8.63046
</code></pre></div></div>

<h2 id="whats-next">Whatâ€™s next</h2>

<p>Now you can explore more ways to run inference and deploy your models:</p>
<ol>
  <li><a href="https://github.com/apache/incubator-mxnet/tree/master/scala-package/examples/src/main/java/org/apache/mxnetexamples/javaapi/infer">Java Inference examples</a></li>
  <li><a href="https://github.com/apache/incubator-mxnet/tree/master/scala-package/examples/src/main/scala/org/apache/mxnetexamples/infer">Scala Inference examples</a></li>
  <li><a href="/api/python/docs/tutorials/packages/onnx/inference_on_onnx_model.html">ONNX model inference examples</a></li>
  <li><a href="https://github.com/awslabs/mxnet-model-server/tree/master/examples">MXNet Model Server Examples</a></li>
</ol>

<h2 id="references">References</h2>

<ol>
  <li><a href="/api/python/docs/tutorials/getting-started/gluon_from_experiment_to_deployment.html">Gluon end to end tutorial</a></li>
  <li><a href="https://github.com/apache/incubator-mxnet/blob/master/cpp-package/example/inference/">Gluon C++ inference example</a></li>
  <li><a href="https://github.com/apache/incubator-mxnet/tree/master/cpp-package">Gluon C++ package</a></li>
</ol>
:ET