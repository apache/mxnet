I"ß1<!--- Licensed to the Apache Software Foundation (ASF) under one -->
<!--- or more contributor license agreements.  See the NOTICE file -->
<!--- distributed with this work for additional information -->
<!--- regarding copyright ownership.  The ASF licenses this file -->
<!--- to you under the Apache License, Version 2.0 (the -->
<!--- "License"); you may not use this file except in compliance -->
<!--- with the License.  You may obtain a copy of the License at -->

<!---   http://www.apache.org/licenses/LICENSE-2.0 -->

<!--- Unless required by applicable law or agreed to in writing, -->
<!--- software distributed under the License is distributed on an -->
<!--- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -->
<!--- KIND, either express or implied.  See the License for the -->
<!--- specific language governing permissions and limitations -->
<!--- under the License. -->

<h1 id="mxnet-perl-symbolic-api">MXNet Perl Symbolic API</h1>

<p>Topics:</p>

<ul>
  <li><a href="#how-to-compose-symbols">How to Compose Symbols</a> introduces operator overloading of symbols.</li>
  <li><a href="#symbol-attributes">Symbol Attributes</a> describes how to attach attributes to symbols.</li>
  <li><a href="#serialization">Serialization</a> explains how to save and load symbols.</li>
  <li><a href="#executing-symbols">Executing Symbols</a> explains how to evaluate the symbols with data.</li>
  <li><a href="#multiple-outputs">Multiple Outputs</a> explains how to configure multiple outputs.</li>
</ul>

<h2 id="how-to-compose-symbols">How to Compose Symbols</h2>

<p>The symbolic API provides a way to configure computation graphs.
You can configure the graphs either at the level of neural network layer operations or as fine-grained operations.</p>

<p>The basic arithmetic operators (plus, minus, div, multiplication) are overloaded for
<em>element-wise operations</em> of symbols.</p>

<p>The following example creates a computation graph that adds two inputs together.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">pdl</span><span class="o">&gt;</span> <span class="k">use</span> <span class="nn">AI::</span><span class="nv">MXNet</span> <span class="sx">qw(mx)</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$a</span> <span class="o">=</span>  <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">symbol</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">a</span><span class="p">")</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$b</span> <span class="o">=</span>  <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">symbol</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">b</span><span class="p">")</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$c</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span>
</code></pre></div></div>

<h2 id="symbol-attributes">Symbol Attributes</h2>

<p>You can add an attribute to a symbol by providing an attribute hash when you create a symbol.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$data</span> <span class="o">=</span>  <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">symbol</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">data</span><span class="p">",</span> <span class="nv">attr</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nv">mood</span> <span class="o">=&gt;</span> <span class="p">"</span><span class="s2">angry</span><span class="p">"</span> <span class="p">})</span>
<span class="nv">$op</span>   <span class="o">=</span>  <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">symbol</span><span class="o">-&gt;</span><span class="nv">Convolution</span><span class="p">(</span><span class="nv">data</span> <span class="o">=&gt;</span> <span class="nv">$data</span><span class="p">,</span> <span class="nv">kernel</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nv">num_filter</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">attr</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nv">mood</span> <span class="o">=&gt;</span> <span class="p">"</span><span class="s2">so so</span><span class="p">"</span> <span class="p">})</span>
</code></pre></div></div>

<p>For proper communication with the C++ backend, both the key and values of the attribute dictionary should be strings. To retrieve the attributes, use <code class="highlighter-rouge">-&gt;attr($key)</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    $data-&gt;attr("mood")
</code></pre></div></div>

<p>To attach attributes, you can use <code class="highlighter-rouge">AI::MXNet::AttrScope</code>. <code class="highlighter-rouge">AI::MXNet::AttrScopeAttrScope</code> automatically adds
the specified attributes to all of the symbols created within that scope.
The user can also inherit this object to change naming behavior. For example:</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">AI::</span><span class="nv">MXNet</span> <span class="sx">qw(mx)</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Test::</span><span class="nv">More</span> <span class="nv">tests</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">my</span> <span class="p">(</span><span class="nv">$data</span><span class="p">,</span> <span class="nv">$gdata</span><span class="p">);</span>
<span class="p">{</span>
    <span class="nb">local</span><span class="p">(</span><span class="nv">$</span><span class="nn">mx::</span><span class="nv">AttrScope</span><span class="p">)</span> <span class="o">=</span> <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">AttrScope</span><span class="p">(</span><span class="nv">group</span><span class="o">=&gt;</span><span class="mi">4</span><span class="p">,</span> <span class="nv">data</span><span class="o">=&gt;</span><span class="p">'</span><span class="s1">great</span><span class="p">');</span>
    <span class="nv">$data</span> <span class="o">=</span> <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">sym</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">data</span><span class="p">",</span> <span class="nv">attr</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nv">dtype</span> <span class="o">=&gt;</span> <span class="p">"</span><span class="s2">data</span><span class="p">",</span> <span class="nv">group</span> <span class="o">=&gt;</span> <span class="p">"</span><span class="s2">1</span><span class="p">"</span> <span class="p">});</span>
    <span class="nv">$gdata</span> <span class="o">=</span> <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">sym</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">data2</span><span class="p">");</span>
<span class="p">}</span>
<span class="nv">ok</span><span class="p">(</span><span class="nv">$gdata</span><span class="o">-&gt;</span><span class="nv">attr</span><span class="p">("</span><span class="s2">group</span><span class="p">")</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
<span class="nv">ok</span><span class="p">(</span><span class="nv">$data</span><span class="o">-&gt;</span><span class="nv">attr</span><span class="p">("</span><span class="s2">group</span><span class="p">")</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$exceedScopeData</span> <span class="o">=</span> <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">sym</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">data3</span><span class="p">");</span>
<span class="nv">ok</span><span class="p">((</span><span class="ow">not</span> <span class="nb">defined</span> <span class="nv">$exceedScopeData</span><span class="o">-&gt;</span><span class="nv">attr</span><span class="p">("</span><span class="s2">group</span><span class="p">")),</span> <span class="p">"</span><span class="s2">No group attr in global attr scope</span><span class="p">");</span>
</code></pre></div></div>

<h2 id="serialization">Serialization</h2>

<p>There are two ways to save and load the symbols. You can use the <code class="highlighter-rouge">mx-&gt;symbol-&gt;save</code> and <code class="highlighter-rouge">mxnet-&gt;symbol-&gt;load</code> functions to serialize the <code class="highlighter-rouge">AI::MXNet::Symbol</code> objects.
The advantage of using <code class="highlighter-rouge">save</code> and <code class="highlighter-rouge">load</code> functions is that it is language agnostic and cloud friendly.
The symbol is saved in JSON format. You can also get a JSON string directly using <code class="highlighter-rouge">$symbol-&gt;tojson</code>.</p>

<p>The following example shows how to save a symbol to an S3 bucket, load it back, and compare two symbols using a JSON string.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">pdl</span><span class="o">&gt;</span> <span class="k">use</span> <span class="nn">AI::</span><span class="nv">MXNet</span> <span class="sx">qw(mx)</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$a</span> <span class="o">=</span> <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">sym</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">a</span><span class="p">")</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nv">mx</span><span class="o">-&gt;</span><span class="nv">sym</span><span class="o">-&gt;</span><span class="nv">Variable</span><span class="p">("</span><span class="s2">b</span><span class="p">")</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$c</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$c</span><span class="o">-&gt;</span><span class="nv">save</span><span class="p">("</span><span class="s2">s3://my-bucket/symbol-c.json</span><span class="p">")</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">$c2</span> <span class="o">=</span> <span class="nv">$c</span><span class="o">-&gt;</span><span class="nv">load</span><span class="p">("</span><span class="s2">s3://my-bucket/symbol-c.json</span><span class="p">")</span>
<span class="nv">pdl</span><span class="o">&gt;</span> <span class="nv">ok</span><span class="p">(</span><span class="nv">$c</span><span class="o">-&gt;</span><span class="nv">tojson</span> <span class="ow">eq</span> <span class="nv">$c2</span><span class="o">-&gt;</span><span class="nv">tojson</span><span class="p">)</span>
<span class="nv">ok</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="executing-symbols">Executing Symbols</h2>

<p>After you have assembled a set of symbols into a computation graph, the MXNet engine can evaluate them.
If you are training a neural network, this is typically
handled by the high-level <a href="module">AI::MXNet::Module package</a> and the [<code class="highlighter-rouge">fit()</code>] function.</p>

<p>For neural networks used in ‚Äúfeed-forward‚Äù, ‚Äúprediction‚Äù, or ‚Äúinference‚Äù mode (all terms for the same
thing: running a trained network), the input arguments are the
input data, and the weights of the neural network that were learned during training.</p>

<p>To manually execute a set of symbols, you need to create an [<code class="highlighter-rouge">AI::MXNet::Executor</code>] object,
which is typically constructed by calling the [<code class="highlighter-rouge">simple_bind(&lt;parameters&gt;)</code>] method on a AI::MXNet::Symbol.</p>
:ET